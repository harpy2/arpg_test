<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dark Realms - ARPG Prototype</title>
<script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #000; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; }
</style>
</head>
<body>
<script>
// ============================================================
// DARK REALMS — Single-file Phaser 3 ARPG Prototype
// ============================================================

const WORLD_W = 3200, WORLD_H = 3200;
const TILE = 64;
const MONSTER_COUNT = { melee: 12, ranged: 8, boss: 2 };

// ---------- helpers ----------
function rnd(a,b){ return Phaser.Math.Between(a,b); }
function dist(a,b){ return Phaser.Math.Distance.Between(a.x,a.y,b.x,b.y); }
function angle(a,b){ return Math.atan2(b.y-a.y, b.x-a.x); }

// ---------- MAIN SCENE ----------
class GameScene extends Phaser.Scene {
  constructor(){ super('Game'); }

  create(){
    this.cameras.main.setBackgroundColor('#1a1a2e');
    this.physics.world.setBounds(0,0,WORLD_W,WORLD_H);

    // --- ground tiles ---
    const gfx = this.add.graphics();
    for(let x=0;x<WORLD_W;x+=TILE){
      for(let y=0;y<WORLD_H;y+=TILE){
        const shade = 0x16213e + rnd(-5,5)*0x010101;
        gfx.fillStyle(shade,1);
        gfx.fillRect(x,y,TILE,TILE);
        gfx.lineStyle(1,0x0f3460,0.3);
        gfx.strokeRect(x,y,TILE,TILE);
      }
    }

    // --- obstacles ---
    this.obstacles = this.physics.add.staticGroup();
    for(let i=0;i<40;i++){
      const ox=rnd(200,WORLD_W-200), oy=rnd(200,WORLD_H-200);
      const w=rnd(40,120), h=rnd(40,120);
      const obs = this.add.rectangle(ox,oy,w,h,0x533483);
      this.physics.add.existing(obs, true);
      this.obstacles.add(obs);
    }

    // --- player ---
    this.player = this.createPlayer(WORLD_W/2, WORLD_H/2);
    this.cameras.main.startFollow(this.player.sprite, true, 0.08, 0.08);
    this.cameras.main.setZoom(1);

    // --- monsters ---
    this.monsters = [];
    this.spawnAllMonsters();

    // --- items on ground ---
    this.groundItems = [];

    // --- projectiles ---
    this.projectiles = [];

    // --- input ---
    this.keys = this.input.keyboard.addKeys('W,A,S,D,UP,DOWN,LEFT,RIGHT,Q,E,I,SPACE');
    this.wKey = this.input.keyboard.addKey('W');
    this.input.keyboard.on('keydown-I', ()=> this.toggleInventory());
    this.input.keyboard.on('keydown-SPACE', ()=> { this.player.autoHunt = !this.player.autoHunt; });

    // --- collisions ---
    this.physics.add.collider(this.player.sprite, this.obstacles);

    // --- HUD scene ---
    this.scene.launch('HUD');
    this.hudScene = this.scene.get('HUD');

    // --- attack on click ---
    this.input.on('pointerdown', (ptr)=>{
      if(this.inventoryOpen) return;
      this.playerAttack(ptr);
    });

    // --- skill cooldowns ---
    this.player.skills = {
      Q: { cd: 2000, last: 0, name: 'Fireball' },
      W: { cd: 5000, last: 0, name: 'Ice Nova' },
      E: { cd: 3000, last: 0, name: 'Dash' },
    };
    this.player.attackCd = 400;
    this.player.lastAttack = 0;
    this.player.autoHunt = false;
    this.player.invincible = false;

    this.inventoryOpen = false;

    // particle-like arrays
    this.damageTexts = [];
    this.effects = [];
  }

  createPlayer(x,y){
    const sprite = this.add.rectangle(x,y,28,32,0x00d2ff);
    sprite.setDepth(10);
    this.physics.add.existing(sprite);
    sprite.body.setCollideWorldBounds(true);
    // small glow
    const glow = this.add.circle(x,y,22,0x00d2ff,0.15).setDepth(9);

    return {
      sprite, glow,
      hp: 100, maxHp: 100,
      atk: 10, def: 5,
      exp: 0, level: 1,
      speed: 220,
      facing: {x:1,y:0},
      inventory: [],
      equipment: { weapon: null, armor: null },
      gold: 0,
      skills: null, attackCd: 0, lastAttack: 0,
      autoHunt: false, invincible: false,
    };
  }

  spawnAllMonsters(){
    for(let i=0;i<MONSTER_COUNT.melee;i++) this.spawnMonster('melee');
    for(let i=0;i<MONSTER_COUNT.ranged;i++) this.spawnMonster('ranged');
    for(let i=0;i<MONSTER_COUNT.boss;i++) this.spawnMonster('boss');
  }

  spawnMonster(type){
    const cfg = {
      melee:  { hp:30, atk:5, exp:10, color:0xe74c3c, size:24, speed:100, range:500, atkRange:40, atkCd:1000 },
      ranged: { hp:20, atk:8, exp:15, color:0x9b59b6, size:20, speed:80, range:600, atkRange:250, atkCd:1500 },
      boss:   { hp:200,atk:15,exp:100,color:0xe67e22, size:44, speed:70, range:700, atkRange:50, atkCd:800 },
    }[type];
    let x,y;
    do { x=rnd(100,WORLD_W-100); y=rnd(100,WORLD_H-100); }
    while(dist({x,y}, this.player.sprite) < 300);

    const sprite = this.add.rectangle(x,y,cfg.size,cfg.size,cfg.color);
    sprite.setDepth(8);
    this.physics.add.existing(sprite);
    sprite.body.setCollideWorldBounds(true);
    this.physics.add.collider(sprite, this.obstacles);

    // hp bar bg + fill
    const hpBg = this.add.rectangle(x, y - cfg.size/2 - 10, cfg.size+10, 5, 0x333333).setDepth(11);
    const hpBar = this.add.rectangle(x, y - cfg.size/2 - 10, cfg.size+10, 5, 0xff0000).setDepth(12);

    const m = { sprite, type, ...cfg, maxHp: cfg.hp, hpBg, hpBar, lastAtk:0, frozen:0, alive:true, projectileCd:0 };
    this.monsters.push(m);
    return m;
  }

  playerAttack(ptr){
    const now = this.time.now;
    if(now - this.player.lastAttack < this.player.attackCd) return;
    this.player.lastAttack = now;

    const wx = ptr.worldX, wy = ptr.worldY;
    const a = Math.atan2(wy - this.player.sprite.y, wx - this.player.sprite.x);
    this.player.facing = { x: Math.cos(a), y: Math.sin(a) };

    // slash effect
    const sx = this.player.sprite.x + Math.cos(a)*35;
    const sy = this.player.sprite.y + Math.sin(a)*35;
    const slash = this.add.arc(sx, sy, 18, 0, 360, false, 0xffffff, 0.7).setDepth(15);
    this.tweens.add({ targets: slash, alpha:0, scaleX:2, scaleY:2, duration:200, onComplete:()=>slash.destroy() });

    // check hits
    const atkBonus = this.player.equipment.weapon ? this.player.equipment.weapon.bonus : 0;
    const dmg = this.player.atk + atkBonus + rnd(-2,2);
    this.monsters.forEach(m=>{
      if(!m.alive) return;
      if(dist({x:sx,y:sy}, m.sprite) < 50){
        this.damageMonster(m, dmg);
      }
    });
  }

  useSkillQ(){
    const sk = this.player.skills.Q;
    const now = this.time.now;
    if(now - sk.last < sk.cd) return;
    sk.last = now;

    const a = Math.atan2(this.player.facing.y, this.player.facing.x);
    const sx = this.player.sprite.x, sy = this.player.sprite.y;
    const fb = this.add.circle(sx, sy, 10, 0xff6600, 1).setDepth(15);
    this.physics.add.existing(fb);
    const speed = 500;
    fb.body.setVelocity(Math.cos(a)*speed, Math.sin(a)*speed);
    const glow = this.add.circle(sx, sy, 16, 0xff6600, 0.3).setDepth(14);

    const proj = { sprite: fb, glow, damage: this.player.atk * 2 + 5, life: 1500, born: now, type:'fireball' };
    this.projectiles.push(proj);
  }

  useSkillW(){
    const sk = this.player.skills.W;
    const now = this.time.now;
    if(now - sk.last < sk.cd) return;
    sk.last = now;

    const px = this.player.sprite.x, py = this.player.sprite.y;
    // visual ring
    const ring = this.add.circle(px,py,10,0x00bfff,0.5).setDepth(15);
    this.tweens.add({ targets:ring, scaleX:15, scaleY:15, alpha:0, duration:500, onComplete:()=>ring.destroy() });

    const dmg = this.player.atk + 3;
    this.monsters.forEach(m=>{
      if(!m.alive) return;
      if(dist(this.player.sprite, m.sprite) < 180){
        this.damageMonster(m, dmg);
        m.frozen = now + 2000;
        m.sprite.fillColor = 0x87ceeb;
      }
    });
  }

  useSkillE(){
    const sk = this.player.skills.E;
    const now = this.time.now;
    if(now - sk.last < sk.cd) return;
    sk.last = now;

    this.player.invincible = true;
    const dashDist = 200;
    const tx = this.player.sprite.x + this.player.facing.x * dashDist;
    const ty = this.player.sprite.y + this.player.facing.y * dashDist;
    // trail
    for(let i=0;i<5;i++){
      const t = this.add.rectangle(
        this.player.sprite.x + this.player.facing.x*i*40,
        this.player.sprite.y + this.player.facing.y*i*40,
        28,32,0x00d2ff,0.3).setDepth(9);
      this.tweens.add({targets:t, alpha:0, duration:300, delay:i*50, onComplete:()=>t.destroy()});
    }

    this.tweens.add({
      targets: this.player.sprite,
      x: Phaser.Math.Clamp(tx,30,WORLD_W-30),
      y: Phaser.Math.Clamp(ty,30,WORLD_H-30),
      duration: 150,
      onComplete: ()=>{ this.player.invincible = false; }
    });
  }

  damageMonster(m, dmg){
    const actual = Math.max(1, dmg);
    m.hp -= actual;
    this.showDamageNumber(m.sprite.x, m.sprite.y - 20, actual, 0xffff00);

    if(m.hp <= 0){
      m.alive = false;
      m.sprite.destroy();
      m.hpBg.destroy();
      m.hpBar.destroy();
      this.player.exp += m.exp;
      this.checkLevelUp();
      this.dropItems(m);
      // respawn after delay
      this.time.delayedCall(rnd(5000,10000), ()=>{
        const idx = this.monsters.indexOf(m);
        if(idx >= 0) this.monsters.splice(idx,1);
        this.spawnMonster(m.type);
      });
    }
  }

  damagePlayer(dmg){
    if(this.player.invincible) return;
    const defBonus = this.player.equipment.armor ? this.player.equipment.armor.bonus : 0;
    const actual = Math.max(1, dmg - this.player.def - defBonus);
    this.player.hp -= actual;
    this.showDamageNumber(this.player.sprite.x, this.player.sprite.y - 25, actual, 0xff4444);
    // flash
    this.player.sprite.fillColor = 0xff0000;
    this.time.delayedCall(100, ()=>{ this.player.sprite.fillColor = 0x00d2ff; });

    if(this.player.hp <= 0){
      this.player.hp = this.player.maxHp;
      this.player.sprite.setPosition(WORLD_W/2, WORLD_H/2);
      this.showDamageNumber(WORLD_W/2, WORLD_H/2 - 40, 'RESPAWN', 0x00ff00);
    }
  }

  checkLevelUp(){
    const needed = this.player.level * 100;
    while(this.player.exp >= needed){
      this.player.exp -= needed;
      this.player.level++;
      this.player.maxHp += 20;
      this.player.hp = this.player.maxHp;
      this.player.atk += 3;
      this.player.def += 2;
      this.showDamageNumber(this.player.sprite.x, this.player.sprite.y - 50, 'LEVEL UP!', 0xffd700);
      // big flash
      const ring = this.add.circle(this.player.sprite.x, this.player.sprite.y, 10, 0xffd700, 0.6).setDepth(20);
      this.tweens.add({targets:ring, scaleX:8, scaleY:8, alpha:0, duration:600, onComplete:()=>ring.destroy()});
    }
  }

  dropItems(m){
    const drops = [];
    const r = Math.random();
    // gold always
    drops.push({type:'gold', color:0xffd700, value:rnd(5,15)});
    if(r < 0.3) drops.push({type:'potion', color:0x2ecc71, value:30});
    if(m.type==='boss'){
      if(Math.random()<0.5) drops.push({type:'weapon', color:0xf1c40f, bonus:rnd(3,8), value:0});
      if(Math.random()<0.5) drops.push({type:'armor', color:0x3498db, bonus:rnd(2,6), value:0});
    } else {
      if(r < 0.08) drops.push({type:'weapon', color:0xf1c40f, bonus:rnd(1,4), value:0});
      if(r < 0.06) drops.push({type:'armor', color:0x3498db, bonus:rnd(1,3), value:0});
    }

    drops.forEach((d,i)=>{
      const ix = m.sprite ? m.sprite.x : m.x;
      const iy = m.sprite ? m.sprite.y : m.y;
      const item = this.add.circle(ix + rnd(-20,20), iy + rnd(-20,20), 7, d.color, 1).setDepth(7);
      // bob
      this.tweens.add({targets:item, y:item.y-4, yoyo:true, repeat:-1, duration:600, ease:'Sine.easeInOut'});
      this.groundItems.push({sprite:item, ...d});
    });
  }

  pickupItems(){
    for(let i=this.groundItems.length-1;i>=0;i--){
      const it = this.groundItems[i];
      if(dist(this.player.sprite, it.sprite) < 30){
        if(it.type==='gold'){
          this.player.gold += it.value;
        } else if(it.type==='potion'){
          this.player.hp = Math.min(this.player.maxHp, this.player.hp + it.value);
          this.showDamageNumber(this.player.sprite.x, this.player.sprite.y-30, '+'+it.value+' HP', 0x2ecc71);
        } else {
          this.player.inventory.push({type:it.type, color:it.color, bonus:it.bonus});
        }
        it.sprite.destroy();
        this.groundItems.splice(i,1);
      }
    }
  }

  showDamageNumber(x,y,text,color){
    const t = this.add.text(x,y,''+text,{fontSize:'16px',fontFamily:'monospace',color:'#'+color.toString(16).padStart(6,'0'),stroke:'#000',strokeThickness:3}).setOrigin(0.5).setDepth(50);
    this.tweens.add({targets:t, y:y-40, alpha:0, duration:800, onComplete:()=>t.destroy()});
  }

  toggleInventory(){
    this.inventoryOpen = !this.inventoryOpen;
    if(this.hudScene) this.hudScene.showInventory = this.inventoryOpen;
  }

  // --- auto hunt ---
  doAutoHunt(){
    if(!this.player.autoHunt) return;
    let nearest = null, nd = Infinity;
    this.monsters.forEach(m=>{
      if(!m.alive) return;
      const d = dist(this.player.sprite, m.sprite);
      if(d < nd){ nd = d; nearest = m; }
    });
    if(!nearest) return;

    const a = angle(this.player.sprite, nearest.sprite);
    this.player.facing = {x:Math.cos(a), y:Math.sin(a)};

    if(nd > 45){
      this.player.sprite.body.setVelocity(Math.cos(a)*this.player.speed, Math.sin(a)*this.player.speed);
    } else {
      this.player.sprite.body.setVelocity(0,0);
    }

    const now = this.time.now;
    // auto attack
    if(nd < 60 && now - this.player.lastAttack >= this.player.attackCd){
      this.player.lastAttack = now;
      const sx = this.player.sprite.x + Math.cos(a)*35;
      const sy = this.player.sprite.y + Math.sin(a)*35;
      const slash = this.add.arc(sx,sy,18,0,360,false,0xffffff,0.7).setDepth(15);
      this.tweens.add({targets:slash,alpha:0,scaleX:2,scaleY:2,duration:200,onComplete:()=>slash.destroy()});
      const atkBonus = this.player.equipment.weapon ? this.player.equipment.weapon.bonus : 0;
      this.monsters.forEach(m2=>{
        if(!m2.alive) return;
        if(dist({x:sx,y:sy}, m2.sprite) < 50) this.damageMonster(m2, this.player.atk + atkBonus + rnd(-2,2));
      });
    }

    // auto skills
    if(nd < 300 && now - this.player.skills.Q.last >= this.player.skills.Q.cd) this.useSkillQ();
    if(nd < 200 && now - this.player.skills.W.last >= this.player.skills.W.cd) this.useSkillW();
    if(nd > 150 && nd < 400 && now - this.player.skills.E.last >= this.player.skills.E.cd) this.useSkillE();
  }

  update(time, delta){
    const p = this.player;
    const sp = p.sprite;

    // --- movement (manual, overridden by auto) ---
    if(!p.autoHunt){
      let vx=0, vy=0;
      if(this.keys.A.isDown||this.keys.LEFT.isDown) vx=-1;
      if(this.keys.D.isDown||this.keys.RIGHT.isDown) vx=1;
      if(this.wKey.isDown||this.keys.UP.isDown) vy=-1;
      if(this.keys.S.isDown||this.keys.DOWN.isDown) vy=1;
      if(vx||vy){
        const len = Math.sqrt(vx*vx+vy*vy);
        vx/=len; vy/=len;
        p.facing = {x:vx, y:vy};
      }
      sp.body.setVelocity(vx*p.speed, vy*p.speed);
    } else {
      this.doAutoHunt();
    }

    // glow follow
    p.glow.setPosition(sp.x, sp.y);

    // --- skills ---
    if(this.keys.Q.isDown) this.useSkillQ();
    if(this.input.keyboard.checkDown(this.input.keyboard.addKey('W'), 500) === false && this.keys.E.isDown) this.useSkillE();
    // W skill: check dedicated key to avoid movement conflict — use right-click or dedicated check
    // Actually let's handle W skill separately since W is also movement
    // We'll use a flag: if W is pressed AND no movement keys... let's just use the skill keys properly
    // Fix: skills on keydown events
    if(!this._skillKeysSetup){
      this._skillKeysSetup = true;
      this.input.keyboard.on('keydown-Q', ()=> this.useSkillQ());
      this.input.keyboard.on('keydown-E', ()=> this.useSkillE());
      // W for Ice Nova: use Shift+W or just detect tap — let's use middle mouse or just allow it with movement
      // Actually, we'll rebind Ice Nova to W only when pressing with shift, or just always trigger it
      // Simplest: W key doubles as move up AND ice nova. Ice nova has long CD so it's fine.
      this.input.keyboard.on('keydown-W', ()=> this.useSkillW());
    }

    // --- projectiles ---
    for(let i=this.projectiles.length-1;i>=0;i--){
      const proj = this.projectiles[i];
      if(time - proj.born > proj.life){
        proj.sprite.destroy();
        if(proj.glow) proj.glow.destroy();
        this.projectiles.splice(i,1);
        continue;
      }
      if(proj.glow){
        proj.glow.setPosition(proj.sprite.x, proj.sprite.y);
      }
      // check monster hits
      this.monsters.forEach(m=>{
        if(!m.alive) return;
        if(dist(proj.sprite, m.sprite) < 30){
          this.damageMonster(m, proj.damage);
          // explosion
          const exp = this.add.circle(proj.sprite.x, proj.sprite.y, 8, 0xff4400, 0.8).setDepth(15);
          this.tweens.add({targets:exp, scaleX:4, scaleY:4, alpha:0, duration:300, onComplete:()=>exp.destroy()});
          proj.sprite.destroy();
          if(proj.glow) proj.glow.destroy();
          proj.life = 0; proj.born = time; // mark for removal
        }
      });
    }

    // --- monster AI ---
    this.monsters.forEach(m=>{
      if(!m.alive) return;
      const d = dist(sp, m.sprite);
      const now = time;

      // unfreeze
      if(m.frozen && now > m.frozen){
        m.frozen = 0;
        const cfg = {melee:0xe74c3c, ranged:0x9b59b6, boss:0xe67e22};
        m.sprite.fillColor = cfg[m.type];
      }

      if(m.frozen && now < m.frozen){
        m.sprite.body.setVelocity(0,0);
      } else if(d < m.range){
        if(d > m.atkRange){
          const a2 = angle(m.sprite, sp);
          m.sprite.body.setVelocity(Math.cos(a2)*m.speed, Math.sin(a2)*m.speed);
        } else {
          m.sprite.body.setVelocity(0,0);
          // attack
          if(now - m.lastAtk > m.atkCd){
            m.lastAtk = now;
            if(m.type==='ranged'){
              // shoot projectile at player
              const a2 = angle(m.sprite, sp);
              const bullet = this.add.circle(m.sprite.x, m.sprite.y, 5, 0xcc66ff, 1).setDepth(12);
              this.physics.add.existing(bullet);
              bullet.body.setVelocity(Math.cos(a2)*300, Math.sin(a2)*300);
              // track enemy projectile
              const ep = {sprite:bullet, born:now, life:2000, damage:m.atk, enemy:true};
              this.projectiles.push(ep);
            } else {
              this.damagePlayer(m.atk);
            }
          }
        }
      } else {
        m.sprite.body.setVelocity(0,0);
      }

      // update hp bar position
      m.hpBg.setPosition(m.sprite.x, m.sprite.y - m.size/2 - 10);
      m.hpBar.setPosition(m.sprite.x, m.sprite.y - m.size/2 - 10);
      const ratio = Math.max(0, m.hp/m.maxHp);
      m.hpBar.width = (m.size+10) * ratio;
    });

    // enemy projectiles hitting player
    for(let i=this.projectiles.length-1;i>=0;i--){
      const proj = this.projectiles[i];
      if(proj.enemy && proj.sprite && proj.sprite.active){
        if(dist(proj.sprite, sp) < 20){
          this.damagePlayer(proj.damage);
          proj.sprite.destroy();
          this.projectiles.splice(i,1);
        }
      }
    }

    // --- item pickup ---
    this.pickupItems();

    // --- update HUD ---
    if(this.hudScene){
      this.hudScene.playerData = {
        hp: p.hp, maxHp: p.maxHp, exp: p.exp, level: p.level,
        atk: p.atk, def: p.def, gold: p.gold,
        skills: p.skills, now: time,
        autoHunt: p.autoHunt,
        inventory: p.inventory,
        equipment: p.equipment,
        px: sp.x, py: sp.y,
        monsters: this.monsters.filter(m=>m.alive).map(m=>({x:m.sprite.x,y:m.sprite.y,type:m.type})),
      };
    }
  }
}

// ---------- HUD SCENE ----------
class HUDScene extends Phaser.Scene {
  constructor(){ super('HUD'); }

  create(){
    this.playerData = {};
    this.showInventory = false;

    // HP bar
    this.hpBg = this.add.rectangle(140, 25, 220, 18, 0x333333).setOrigin(0,0.5).setScrollFactor(0);
    this.hpFill = this.add.rectangle(140, 25, 220, 18, 0xe74c3c).setOrigin(0,0.5).setScrollFactor(0);
    this.hpText = this.add.text(145, 25, '', {fontSize:'12px',fontFamily:'monospace',color:'#fff'}).setOrigin(0,0.5).setScrollFactor(0).setDepth(1);
    this.levelText = this.add.text(20, 18, 'Lv 1', {fontSize:'20px',fontFamily:'monospace',color:'#ffd700',stroke:'#000',strokeThickness:3}).setScrollFactor(0);

    // EXP bar
    this.expBg = this.add.rectangle(140, 48, 220, 10, 0x333333).setOrigin(0,0.5).setScrollFactor(0);
    this.expFill = this.add.rectangle(140, 48, 220, 10, 0x2ecc71).setOrigin(0,0.5).setScrollFactor(0);
    this.expText = this.add.text(145, 48, '', {fontSize:'9px',fontFamily:'monospace',color:'#fff'}).setOrigin(0,0.5).setScrollFactor(0).setDepth(1);

    // Stats
    this.statsText = this.add.text(20, 60, '', {fontSize:'11px',fontFamily:'monospace',color:'#aaa'}).setScrollFactor(0);

    // Gold
    this.goldText = this.add.text(20, 90, '', {fontSize:'12px',fontFamily:'monospace',color:'#ffd700'}).setScrollFactor(0);

    // Skill bar
    const sw = this.cameras.main.width;
    const sh = this.cameras.main.height;
    this.skillSlots = [];
    const skillKeys = ['Q','W','E'];
    const skillNames = ['Fireball','Ice Nova','Dash'];
    const skillColors = [0xff6600, 0x00bfff, 0x00d2ff];
    skillKeys.forEach((k,i)=>{
      const x = sw/2 - 80 + i*80;
      const y = sh - 45;
      const bg = this.add.rectangle(x,y,60,50,0x222222,0.8).setScrollFactor(0).setStrokeStyle(2,skillColors[i]);
      const label = this.add.text(x,y-12,k,{fontSize:'16px',fontFamily:'monospace',color:'#fff',stroke:'#000',strokeThickness:2}).setOrigin(0.5).setScrollFactor(0);
      const name = this.add.text(x,y+5,skillNames[i],{fontSize:'8px',fontFamily:'monospace',color:'#aaa'}).setOrigin(0.5).setScrollFactor(0);
      const cdText = this.add.text(x,y+18,'',{fontSize:'10px',fontFamily:'monospace',color:'#ff4444'}).setOrigin(0.5).setScrollFactor(0);
      const overlay = this.add.rectangle(x,y,60,50,0x000000,0.6).setScrollFactor(0);
      this.skillSlots.push({bg,label,name,cdText,overlay,key:k});
    });

    // Auto indicator
    this.autoText = this.add.text(sw/2, sh - 80, '⚔ AUTO ⚔', {fontSize:'18px',fontFamily:'monospace',color:'#ffd700',stroke:'#000',strokeThickness:3}).setOrigin(0.5).setScrollFactor(0).setVisible(false);

    // Mini-map
    this.miniMapBg = this.add.rectangle(sw-75, 75, 120, 120, 0x111111, 0.7).setScrollFactor(0).setStrokeStyle(1,0x444444);
    this.miniMapGfx = this.add.graphics().setScrollFactor(0);

    // Inventory panel
    this.invPanel = this.add.container(sw/2, sh/2).setScrollFactor(0).setVisible(false).setDepth(100);
    const invBg = this.add.rectangle(0,0,320,400,0x1a1a2e,0.95).setStrokeStyle(2,0x555555);
    const invTitle = this.add.text(0,-180,'INVENTORY',{fontSize:'16px',fontFamily:'monospace',color:'#ffd700'}).setOrigin(0.5);
    this.invPanel.add([invBg, invTitle]);
    this.invSlots = [];
    this.invEquipSlots = [];

    // equipment labels
    const wepLabel = this.add.text(-120,-150,'Weapon:',{fontSize:'11px',fontFamily:'monospace',color:'#f1c40f'});
    const armLabel = this.add.text(-120,-130,'Armor:',{fontSize:'11px',fontFamily:'monospace',color:'#3498db'});
    this.invWeaponText = this.add.text(-50,-150,'None',{fontSize:'11px',fontFamily:'monospace',color:'#888'});
    this.invArmorText = this.add.text(-50,-130,'None',{fontSize:'11px',fontFamily:'monospace',color:'#888'});
    this.invPanel.add([wepLabel, armLabel, this.invWeaponText, this.invArmorText]);

    // grid
    for(let r=0;r<4;r++){
      for(let c=0;c<6;c++){
        const sx = -120 + c*45;
        const sy = -90 + r*45;
        const slot = this.add.rectangle(sx,sy,40,40,0x2a2a4a).setStrokeStyle(1,0x444466);
        const icon = this.add.circle(sx,sy,10,0x000000,0).setDepth(101);
        this.invPanel.add([slot, icon]);
        this.invSlots.push({slot, icon, x:sx, y:sy});
      }
    }

    // controls help
    this.add.text(20, sh-20, 'WASD:Move  Click:Attack  Q/W/E:Skills  I:Inventory  SPACE:Auto', {fontSize:'10px',fontFamily:'monospace',color:'#555'}).setOrigin(0,1).setScrollFactor(0);
  }

  update(){
    const d = this.playerData;
    if(!d || !d.hp) return;

    // HP
    const hpRatio = d.hp / d.maxHp;
    this.hpFill.width = 220 * hpRatio;
    this.hpText.setText(d.hp + ' / ' + d.maxHp);
    this.levelText.setText('Lv ' + d.level);

    // EXP
    const needed = d.level * 100;
    this.expFill.width = 220 * (d.exp / needed);
    this.expText.setText('EXP ' + d.exp + '/' + needed);

    // Stats
    this.statsText.setText('ATK:' + d.atk + '  DEF:' + d.def);
    this.goldText.setText('Gold: ' + d.gold);

    // Skills
    this.skillSlots.forEach(s=>{
      const sk = d.skills[s.key];
      if(!sk) return;
      const remaining = Math.max(0, sk.cd - (d.now - sk.last));
      if(remaining > 0){
        s.overlay.setVisible(true);
        s.overlay.height = 50 * (remaining / sk.cd);
        s.cdText.setText((remaining/1000).toFixed(1));
      } else {
        s.overlay.setVisible(false);
        s.cdText.setText('');
      }
    });

    // Auto
    this.autoText.setVisible(d.autoHunt);

    // Mini-map
    const mg = this.miniMapGfx;
    const mx = this.cameras.main.width - 135, my = 15;
    mg.clear();
    const scale = 120 / WORLD_W;
    // player
    mg.fillStyle(0x00d2ff,1);
    mg.fillCircle(mx + d.px*scale, my + d.py*scale, 3);
    // monsters
    if(d.monsters){
      d.monsters.forEach(m=>{
        const c = m.type==='melee'?0xe74c3c:m.type==='ranged'?0x9b59b6:0xe67e22;
        mg.fillStyle(c, 0.8);
        mg.fillCircle(mx + m.x*scale, my + m.y*scale, m.type==='boss'?3:1.5);
      });
    }

    // Inventory
    this.invPanel.setVisible(this.showInventory);
    if(this.showInventory){
      // update equipment text
      this.invWeaponText.setText(d.equipment.weapon ? 'ATK +'+d.equipment.weapon.bonus : 'None');
      this.invArmorText.setText(d.equipment.armor ? 'DEF +'+d.equipment.armor.bonus : 'None');
      // update slots
      this.invSlots.forEach((s,i)=>{
        if(i < d.inventory.length){
          const it = d.inventory[i];
          s.icon.fillColor = it.color;
          s.icon.fillAlpha = 1;
        } else {
          s.icon.fillAlpha = 0;
        }
      });
    }

    // auto-equip best items
    if(d.inventory){
      d.inventory.forEach((it,i)=>{
        if(it.type==='weapon'){
          if(!d.equipment.weapon || it.bonus > d.equipment.weapon.bonus){
            d.equipment.weapon = it;
          }
        }
        if(it.type==='armor'){
          if(!d.equipment.armor || it.bonus > d.equipment.armor.bonus){
            d.equipment.armor = it;
          }
        }
      });
    }
  }
}

// ---------- CONFIG ----------
const config = {
  type: Phaser.AUTO,
  width: Math.min(1200, window.innerWidth),
  height: Math.min(800, window.innerHeight),
  parent: document.body,
  backgroundColor: '#0a0a1a',
  physics: {
    default: 'arcade',
    arcade: { debug: false }
  },
  scene: [GameScene, HUDScene],
  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH,
  }
};

const game = new Phaser.Game(config);
</script>
</body>
</html>
